import numpy as np
from pycuda import compiler, driver
from pycuda import autoinit

#kernel declaration
mod = compiler.SourceModule("""
__device__ unsigned int idx3d(int i, int k, int l, int M, int P)
{
    return k*P + i*M*P + l;

}

__device__ unsigned int idx2d(int i, int j, int M)
{
    return j + i*M;

}


__global__ void distance2(int N, int M, int P, float *d1, float *d2, float *res2)
{
    int i = threadIdx.x + blockDim.x * blockIdx.x;
    int j = threadIdx.y + blockDim.y * blockIdx.y;

    if((i>=N)||(j>=N)) return;
    float x;
    x = 0.0;

    for(int k=0; k<M; k++){
    	    for(int l=0; l<P; l++){
	           x = x+ d2[idx3d(i,k,l,M,P)]-d1[idx3d(j,k,l,M,P)];
	    }
    }

    res2[idx2d(i,j,N)] = x;

}
""")



#make data
#data1 = np.random.normal(loc=0.0, scale=1,size=(3,2,4)).astype(np.float32)

data1 = np.zeros([29,6,5]).astype(np.float32)

data2 = data1 + 1.0
print data1

data2 = data2.astype(np.float32)

N=data1.shape[0]
M=data1.shape[1]
P=data1.shape[2]

print "N: ",N
print "M: ",M
print "P: ",P

res2 = np.zeros([N,N]).astype(np.float32)


#invoke kernel
dist_gpu = mod.get_function("distance2")
#dist_gpu(np.int32(N), np.int32(M), np.int32(P), driver.In(data1), driver.In(data2), driver.Out(res2), block=(22,22,1), grid=(np.int(np.ceil(N*M*P/22.0)),np.int(np.ceil(N*M*P/22.0))))

if(N<22):
    dist_gpu(np.int32(N), np.int32(M), np.int32(P), driver.In(data1), driver.In(data2), driver.Out(res2), block=(N,N,1), grid=(1,1))
else:
    g = np.ceil(N/22.0)
    dist_gpu(np.int32(N), np.int32(M), np.int32(P), driver.In(data1), driver.In(data2), driver.Out(res2), block=(22,22,1), grid=(int(g),int(g)))

print res2



# question: how to check that it does not unecessary calculations???