#!/usr/bin/python2.5

from numpy import *
from numpy.random import *
import abcsysbio
import sys
import re
import time, os

import cudasim
import cudasim.EulerMaruyama as EulerMaruyama
import cudasim.Gillespie as Gillespie
import cudasim.Lsoda as Lsoda

from abcsysbio import parse_infoEnt
from abcsysbio import model_py
from abcsysbio import model_cu
from abcsysbio import model_c
from abcsysbio import data
from abcsysbio import input_output

import abcsysbio_parser
from abcsysbio_parser import ParseAndWrite

import sys
sys.path.insert(0, ".")



def getWeightedSample(weights):

    totals = []
    running_total = 0

    for w in weights:
        running_total = running_total + w[0]
        totals.append(running_total)

    rnd = random() * running_total
    for i, total in enumerate(totals):
        if rnd < total:
            return i

    
def checkNAs(result):
    
    index = []
    for i in range(len(result)):
    	# loop over species
	l = 0
	isok = True
	while (isok and (l<(len(result[i][0])-1))):
	    # loop over timepoints
            for k in range(len(result[i][0][l])):
                if isnan(result[i][0][l][k]) ==True:
		    index.append(i)
		    isok = False
		    break
	    l = l+1
    return(index)
		       				
def removeNAs(result, parameter,index):
    p = parameter
    x = result    
    xKeep = []
    pKeep = []
    xRemove = []
    pRemove = []
    
    for i in range(len(p)):
        rem = False
        for j in range(len(index)):
	    if index[j] == i:
	        pRemove.append(p[i])
		xRemove.append(x[i][0])
		rem = True
	if rem == False:
	    pKeep.append(p[i])
	    xKeep.append(x[i][0])

    return(xKeep,pKeep,xRemove,pRemove)


def print_results(result, outfile,timepoints):
    out = open(outfile,'w')
    print >>out, 0, 0, 0,
    for i in range(len(timepoints)-1):
        print >>out, timepoints[i+1],
    print >>out, ""
    # loop over threads
    for i in range(len(result)):
        # loop over species
        for l in range(len(result[i][0])):
                
	    print >>out, i,"0",l,
            for k in range(len(timepoints)-1):
                print >>out, result[i][k][l],
            print >>out, ""

    out.close()



def print_parameters(param, outfile):

    out = open(outfile,'w')
    
    for i in range(len(param)):
    	for j in range(len(param[i])):
	    print >>out, param[i][j],
	print >>out, ""

    out.close()

def prod( iterable ):
    p= 1
    for n in iterable:
        p *= n
    return p

def getEntropy1(data,N,sigma,theta):

    xRef = data
    p1 = array(theta)

    N1 = 100000
    N2 = 100000    

    sum1 = 0
    counter = 0



    for i in range(N1):
    	sum2 = 0.0
	sP2 = 1.0

	for m in range(len(xRef[0])):
	    for n in range(len(xRef[0][0])):
  	       sP2 = sP2 * 1.0/sqrt(2.0*pi*sigma*sigma)*exp(-(p1[N1:(N1+N2),m,n]-xRef[i,m,n])*(p1[N1:(N1+N2),m,n]-xRef[i,m,n])/(2.0*sigma*sigma))

	sum2 = sum(sP2)
	if(isinf(log(sum2/N2))): counter=counter+1
	else: sum1 = sum1 - log(sum2/N2)
   
 







   Info = sum1/N1

    print "counter: ",counter


    out = open('results','w')
    
    print >>out, "counter: ",counter
    print >>out, "mutual info: ", Info

    out.close()

    return(Info)



def getEntropy2(dataRef,dataY,N,sigma,theta1,theta2):

    xRef = dataRef
    y = dataY
    p1 = array(theta1)
    p2 = array(theta2)

    N1 = 1000
    N2 = 1000
    N3 = 1000
    N4 = 1000

    sum1 = 0.0
    a1=0.0
    a2=0.0
    a3=0.0


    for i in range(N1):
   
	sP2 = 1.0
	sP3 = 1.0
	sP4 = 1.0

	
	for m in range(len(xRef[0])):
	    for n in range(len(xRef[0][0])):
  	       sP3 = sP3 * 1.0/sqrt(2.0*pi*sigma*sigma)*exp(-(p1[(N1+N2):(N1+N2+N3),m,n]-xRef[i,m,n])*(p1[(N1+N2):(N1+N2+N3),m,n]-xRef[i,m,n])/(2.0*sigma*sigma))
 	       sP4 = sP4 * 1.0/sqrt(2.0*pi*sigma*sigma)*exp(-(p2[(N1+N2+N3):(N1+N2+N3+N4),m,n]-y[i,m,n])*(p2[(N1+N2+N3):(N1+N2+N3+N4),m,n]-y[i,m,n])/(2.0*sigma*sigma))
	       sP2 = sP2 * 1.0/sqrt(2.0*pi*sigma*sigma)*exp(-(p1[N1:(N1+N2),m,n]-xRef[i,m,n])*(p1[N1:(N1+N2),m,n]-xRef[i,m,n])/(2.0*sigma*sigma)) * 1.0/sqrt(2.0*pi*sigma*sigma)*exp(-(p2[N1:(N1+N2),m,n]-y[i,m,n])*(p2[N1:(N1+N2),m,n]-y[i,m,n])/(2.0*sigma*sigma))

	sum2 = sum(sP2)
	sum3 = sum(sP3)
	sum4 = sum(sP4)
	    
	
    	sum1 = sum1 + log(sum2/N2) - log(sum3/N3) - log(sum4/N4)

	a1 = a1+log(sum2/N2)
	a2 = a2+log(sum3/N3)
	a3 = a3+log(sum4/N4)
	
    
    print "a1: ", a1/float(i+1) , "a2: ", a2/float(i+1), "a3: ", a3/float(i+1)
    print "all: ",  a1/float(i+1) - a2/float(i+1) - a3/float(i+1)


    Info = sum1/N1
    return(Info)



def printOptions():
    
    print "\nList of possible options:"

    print "\n Input options:"
    print "-i\t--infile\t declaration of the input file. This input file has to be provided to run the program!"
    print "-lc\t--localcode\t do not import model from sbml intead use a local .py, .hpp/.cpp or .cu file"

    print "\n Algorithmic options:"
    print "-sd\t--setseed\t seed the random number generator in numpy with an integer eg -sd=2, --setseed=2"
    print "-tm\t--timing\t print timing information"
    print "--c++\t\t\t use C++ implementation"
    print "-cu\t--cuda\t\t use CUDA implementation"
    
    print "\n Output options:"  
    print "-of\t--outfolder\t write results to folder eg -of=/full/path/to/folder (default is _results_ in current directory)"
    print "-f\t--fulloutput\t print epsilon, sampling steps and acceptence rates after each population"
    print "-s\t--save\t\t no backup after each population"
    print "-db\t--debug\t set the debug mode"
    
    print "\n Simulate options:"
    print "-S\t--simulate\t simulate the model over the range of timepoints, using paramters sampled from the priors"

    print "\n Design options:"
    print "-D\t--design\t run ABC-SysBio in design mode"
    
    print "\n Plotting options:"
    print "-d\t--diagnostic\t no printing of diagnostic plots"
    print "-t\t--timeseries\t no plotting of simulation results after each population"
    print "-p\t--plotdata\t no plotting of given data points"
    print "\n-h\t--help\t\t print this list of options."

    print "\n"

    
def main():
    
    diagnostic=True
    pickling=True
    file_exist=False
    plot=True
    plotTimeSeries=True
    simulate=False
    design=False
    full=False
    usesbml=True
    seed = None
    timing = False
    fname = "_results_"
    custom_kernel = False
    custom_distance = False
    use_cuda = False
    use_c = False
    full_debug = False

    for i in range(1,len(sys.argv)):

        if sys.argv[i].startswith('--'):
            option = sys.argv[i][2:]
          
            if option == 'help':
                printOptions()
                sys.exit()
            elif option == 'diagnostic': diagnostic=False
            elif option == 'save': pickling=False
            elif option == 'timeseries': plotTimeSeries=False
            elif option == 'plotdata': plot=False
            elif option == 'simulate': simulate=True
            elif option == 'design': design=True
            elif option == 'debug': full_debug=True
            elif option == 'fulloutput': full=True
	    elif option == 'localcode' : usesbml = False 
            elif option[0:8] == 'setseed=' : seed = int( option[8:] )
            elif option[0:10] == 'outfolder=' : fname = option[10:]
            elif option[0:9] == 'cudacode=' : app_file = option[9:]
	    elif option == 'timing' : timing = True 
	    elif option == 'custk' : custom_kernel = True
	    elif option == 'custd' : custom_distance = True
            elif option == 'cuda' : use_cuda = True
            elif option == 'c++' : use_c = True
	    elif option == 'infile': 
                input_file=sys.argv[i+1]
                file_exist=True
	    elif not(sys.argv[i-1][2:] == 'infile'): 
                print "\nunknown option "+sys.argv[i]
                printOptions()
                sys.exit()
            
        
        elif sys.argv[i].startswith('-'):
            option = sys.argv[i][1:]
            if option == 'h':
                printOptions()
                sys.exit()
            elif option == 'd': diagnostic=False
            elif option == 's': pickling=False
            elif option == 't': plotTimeSeries=False
            elif option == 'p': plot=False
            elif option == 'S': simulate=True
            elif option == 'D': design=True
            elif option == 'db': full_debug=True
            elif option == 'f': full=True
            elif option == 'cu': use_cuda = True
	    elif option == 'lc' : usesbml = False
            elif option[0:3] == 'sd=' : seed = int( option[3:] )
            elif option[0:3] == 'of=' : fname = option[3:]
            elif option == 'tm' : timing = True
            elif option == 'i': 
                input_file=sys.argv[i+1]
                file_exist=True
            elif not(sys.argv[i-1][2:] == 'i'): 
                print "\nunknown option "+sys.argv[i]
                printOptions()
                sys.exit()
        elif not((sys.argv[i-1][2:] == 'infile') or (sys.argv[i-1][1:] == 'i')):
            print "\nunknown expression \""+sys.argv[i]+"\""
            printOptions()
            sys.exit()

    if file_exist == False:
        print "\nNo input_file is given!\nUse: \n\t-i 'inputfile' \nor: \n\t--infile 'inputfile' \n"
        sys.exit()

    # python, C++ or CUDA 
    if use_cuda == True and use_c == True:
        print "specified both c++ and CUDA "
        sys.exit()
    if design == True and simulate==True:
        print "specified both design and simulate "
        sys.exit()

    # parse the input file
    mode = 0
    if simulate == True: mode = 1
    if design == True: mode = 2
    info_new = parse_infoEnt.algorithm_info(input_file, mode) 

    info_new.print_info()

    # Check that we have libSBML if it is requested
    if usesbml == True:
        try: import libsbml
        except ImportError:
            print "ABORT: libSBML required for SBML parsing. Please install libSBML"
            sys.exit()

    # Check that we can import scipy if we have ODE models
    o = re.compile('ODE')
    for m in range( info_new.nmodels ):
        if o.search(info_new.type[m]):
            try: from scipy.integrate.odepack import odeint
            except ImportError:
                print "ABORT: scipy required for ODE modelling. Please install scipy"
                sys.exit()
            break

    # Check that we have cuda-sim installed
    if use_cuda == True:
        try: import cudasim
        except ImportError:
            print "ABORT: cudasim required for running on CUDA GPUs. Please install cuda-sim"
            sys.exit()
    
    # set the random seeds
    if seed != None:
	print "#### Seeding random number generator : ", seed
        numpy.random.seed(seed)


    # Check the information is correct for simulation
    modelCorrect = False
    if usesbml == True :
        integrationType = []
        
        if use_cuda == True:
            # CUDA
            for i in range(len(info_new.type)):
                integrationType.append(info_new.type[i]+' CUDA')
        elif use_c == True :
            # C
            for i in range(len(info_new.type)):
                if info_new.type[i] == "SDE":
                    info_new.type[i] = "EulerSDE"
                integrationType.append(info_new.type[i]+' C')
        else:
            # python 
            for i in range(len(info_new.type)):
                integrationType.append(info_new.type[i]+' Python')
            

        ParseAndWrite.ParseAndWrite(info_new.source,integrationType,info_new.name,inputPath="",outputPath="",method=None)


    print("Parsing done")
    print("Starting Simulation...")
    modelTraj = []


    sampleFromPost = False
    referenceModel = True

    #loop over models

    try:
        os.mkdir("acceptedParticles")
    except:
	print "\nThe folder acceptedParticles already exists!\n"
        sys.exit()

    try:
        os.mkdir("rejectedParticles")
    except:
	print "\nThe folder rejectedParticles already exists!\n"
        sys.exit()



    for mod in range(info_new.nmodels):

    	print "Model:",mod+1
    	parametersKeepFinal = []
	parametersRemoveFinal = []
	resultKeepFinal = []
	resultRemoveFinal = []

    	modelTraj.append([])
	accepted = 0
	while(accepted<info_new.particles):
	    if(mod==0): parameters = zeros( [info_new.particles,len(info_new.prior[mod])] )	
    	    species = zeros([info_new.particles,info_new.nspecies[mod]])

            for i in range(info_new.particles):
            	for j in range(info_new.nspecies[mod]):
                    species[i,j] = info_new.x0prior[mod][j][1]

       	    if(mod==0 and sampleFromPost==False):
		for j in range(len(info_new.prior[mod])):
                    if(info_new.prior[mod][j][0]==0):
			for i in range(info_new.particles):
                            parameters[i,j] = info_new.prior[mod][j][1]
                    if(info_new.prior[mod][j][0]==2):
			parameters[:,j] = uniform(low=info_new.prior[mod][j][1], high=info_new.prior[mod][j][2],size=(1,1,info_new.particles))[0][0]
        	    if(info_new.prior[mod][j][0]==1):
			parameters[:,j] = normal(loc=info_new.prior[mod][j][1], scale=info_new.prior[mod][j][2],size=(1,1,info_new.particles))[0][0]
            if(mod==0 and sampleFromPost==True):
		infileName = "data"+`mod+1`+".txt"
		in_file=open(infileName, "r")
	        matrix=[]
	        param=[]
		counter=0
		for in_line in in_file.readlines():
		    in_line=in_line.rstrip()
		    matrix.append([])
		    param.append([])
    		    matrix[counter]=in_line.split(" ")
		    param[counter] = map(float, matrix[counter])
    		    counter=counter+1
		in_file.close

		infileName = "data_Weights"+`mod+1`+".txt"
		in_file=open(infileName, "r")
	        matrix=[]
	        weights=[]
		counter2=0
		for in_line in in_file.readlines():
		    in_line=in_line.rstrip()
		    matrix.append([])
		    weights.append([])
    		    matrix[counter2]=in_line.split(" ")
		    weights[counter2] = map(float, matrix[counter2])
    		    counter2=counter2+1
		in_file.close

		if not(counter == counter2):
		    print ""
		    print "Please provide equal number of particles and weights in model ", mod+1, "!"
		    sys.exit()
		else:
		    parameters = zeros( [info_new.particles,len(param[0])] )
		    		    
		    index = getWeightedSample(weights)

		    for i in range(info_new.particles):
		        index = getWeightedSample(weights)
		    	for j in range(len(param[0])):
			    parameters[i,j] = param[index][j]
 
    
		
	    # simulate model mod
            cudaCode = info_new.name[mod] + '.cu'
	    modelInstance = Lsoda.Lsoda(info_new.times, cudaCode, dt=info_new.dt)
            result0 = modelInstance.run(parameters, species)	

	    n = shape(result0)[2]
       	    result = result0[:,:,1:n,:]
	    print shape(result)

	    # check for NAs in results and remove corresponding particles
	    print shape(result)
	    index = checkNAs(result)
	    resultKeep, parametersKeep, resultRemove, parametersRemove = removeNAs(result, parameters,index)
	
	    # merge result and parameters
	    for r in range(len(resultKeep)):
	 	resultKeepFinal.append(resultKeep[r])
		parametersKeepFinal.append(parametersKeep[r])
	    for r in range(len(resultRemove)):
		resultRemoveFinal.append(resultRemove[r])
		parametersRemoveFinal.append(parametersRemove[r])

	    accepted = len(parametersKeepFinal)
	    rejected = len(parametersRemoveFinal)
	
	print " "
        print "accepted: ", accepted, ", rejected: ", rejected, ", acceptence rate: ", float(accepted)/float(accepted+rejected)
	print " "
	#use the first N particles only
	del resultKeepFinal[info_new.particles:]
	del parametersKeepFinal[info_new.particles:]
	

	# create list that contains parameters theta and variables x
	modelTraj[mod].append(parametersKeepFinal)
	modelTraj[mod].append(resultKeepFinal)


	# write out sampled parameters and trajectories for accepted and rejected particles

	fileName =  "acceptedParticles/model"+`mod+1`+"_trajectories_accepted.txt"
	print_results(resultKeepFinal,fileName,info_new.times)
	
	fileName =  "acceptedParticles/model"+`mod+1`+"_parameters_accepted.txt"
	print_parameters(parametersKeepFinal,fileName)

	fileName =  "rejectedParticles/model"+`mod+1`+"_parameters_rejected.txt"
	print_parameters(parametersRemoveFinal,fileName)



    sigma = 50.0

    ftheta = []

    for mod in range(info_new.nmodels):
    	trajTemp = array(modelTraj[mod][1])
        ftheta.append(trajTemp[:,:,:] + normal(loc=0.0, scale=sigma,size=(info_new.particles,len(info_new.times)-1,info_new.nspecies[mod])))
	    




    print("Simulation done")
    print "------------------------ "
    print " "

    # compute I(theta,x)        
    print("Mutual information calculation 1... ")

    MutInfo1 = []
    for mod in range(info_new.nmodels):
 	N = info_new.particles

     	MutInfo1.append(getEntropy1(ftheta[mod],N,sigma,modelTraj[mod][1]))
     	print "I(theta,X",mod+1,") = ", MutInfo1[mod]


    # compute I(x,y) for reference model

    if referenceModel == True:
        MutInfo2 = []
        print("Mutual information calculation 2... ")
	MutInfo2.append("NA")
	for mod in range(1,info_new.nmodels):
	    N = info_new.particles
   	    MutInfo2.append(getEntropy2(ftheta[0],ftheta[mod],N,sigma,modelTraj[0][1],modelTraj[mod][1]))
   	    print "I(X(reference model),X(model",mod+1,") = ", MutInfo2[mod]





main()
