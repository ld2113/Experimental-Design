import numpy as np
from pycuda import compiler, driver
from pycuda import autoinit

#kernel declaration
mod = compiler.SourceModule("""
__device__ unsigned int idx2d(int i, int j, int lda)
{
    return j + i*lda;
}



__global__ void distance(int N, int M, float *d1, float *d2, float *res)
{
    int i = threadIdx.x + blockDim.x * blockIdx.x;
    int j = threadIdx.y + blockDim.y * blockIdx.y;
    float x, y, z;
    x = d2[idx2d(j,0,3)]-d1[idx2d(i,0,3)];
    y = d2[idx2d(j,1,3)]-d1[idx2d(i,1,3)];
    z = d2[idx2d(j,2,3)]-d1[idx2d(i,2,3)];

    res[idx2d(i,j,N)] = x + y + z;
}

__global__ void distance2(int N, int M, float *d1, float *d2, float *res2)
{
    int i = threadIdx.x + blockDim.x * blockIdx.x;
    float x;
    x = 0.0;

    for(int k=0; k<M; k++){

    	    x = x+ d2[idx2d(i,k,M)]-d1[idx2d(i,k,M)];

    }

    res2[i] = x;

}
""")

#make data
data1 = np.zeros([3,3]).astype(np.float32)

data1[0,:]=[1,2,3]
data1[1,:]=[4,5,6]
data1[2,:]=[7,8,9]


data2 = np.zeros([3,3]).astype(np.float32)

data2[0,:]=[1,2,3]
data2[1,:]=[4,5,6]
data2[2,:]=[7,8,9]
data2 = data2+1

N=data1.shape[0]
M=data2.shape[0]

N=data1.shape[0]
M=data2.shape[0]

res = np.zeros([N,M]).astype(np.float32) # NxM matrix

#invoke kernel
dist_gpu = mod.get_function("distance")
dist_gpu(np.int32(N), np.int32(M), driver.In(data1), driver.In(data2), driver.Out(res), block=(N,M,1), grid=(1,1))



#make data
data1 = np.zeros([3,4]).astype(np.float32)

data1[0,:]=[1,2,3,4]
data1[1,:]=[5,6,7,8]
data1[2,:]=[9,10,11,12]


data2 = np.zeros([3,4]).astype(np.float32)

data2[0,:]=data1[0,:]+1.0
data2[1,:]=data1[1,:]+5.0
data2[2,:]=data1[2,:]+3.0

print data1
print data2

N=data1.shape[0]
M=data1.shape[1]

print "M: ",M
print "N: ",N
#res2 = np.zeros([N,M]).astype(np.float32) # NxM matrix
res2 = np.zeros([3]).astype(np.float32)

#invoke kernel
dist_gpu = mod.get_function("distance2")
dist_gpu(np.int32(N), np.int32(M), driver.In(data1), driver.In(data2), driver.Out(res2), block=(M,1,1), grid=(1,1))

print res2

# next to do: expand to 3D!!! for each species and sum up, so change the index function, result should keep the same format just sum over a third dimension
# when this is done add it to the original code and do short test runs
# question: how to check that it does not unecessary calculations???